% iniciar_presimulacion.m
% Pipeline completo con bondad_ajuste incluido y GENERACIÓN DE RUTEO INTELIGENTE

clear all; clc;

% Iniciar temporizador
tic;

% Paso 0: Agregar carpetas al path
addpath('scripts');
addpath('datos');

fprintf('? INICIANDO PIPELINE DE INICIALIZACIÓN\n');
fprintf('========================================\n');


%% Paso 1: Procesar datos crudos
fprintf('\n1. Procesando datos crudos...\n');
try
    procesar_datos_finales();
    fprintf('? Datos procesados exitosamente\n');
catch ME
    error('? Error en procesar_datos_finales: %s', ME.message);
end

%% Paso 2: Análisis de bondad de ajuste
fprintf('\n2. Ejecutando análisis de bondad de ajuste...\n');
try
    bondad_ajuste();
    fprintf('? Análisis de bondad completado\n');
    
    % Extraer parámetros del análisis
    % Como bondad_ajuste no guarda resultados en variables, los cargamos/calculamos
    load('output\parametros_simulacion_final.mat');
    datos = master_data.am_total;
    datos = datos(~isnan(datos) & datos > 0);
    mu_log = mean(log(datos));
    sigma_log = std(log(datos));
    
catch ME
    warning('?? Error en bondad_ajuste (calculando directamente): %s', ME.message);
    load('parametros_simulacion_final.mat');
    datos = master_data.am_total;
    datos = datos(~isnan(datos) & datos > 0);
    mu_log = mean(log(datos));
    sigma_log = std(log(datos));
end

%% Paso 3: Calcular tasas reales y aplicar FACTORES DE CORRECCIÓN
fprintf('\n3. Calculando parámetros con corrección de distribución...\n');
try
    load('output\parametros_simulacion_final.mat');
    
    % --- CONFIGURACIÓN DE ESCENARIO ---
    T_sesion = 300;         % Duración promedio de sesión (5 min)
    
    % FACTORES DE CORRECCIÓN (TUNING)
    factor_correccion_AM = 1.0;  
    factor_correccion_FM = 2.5;  % <--- Corrección de demanda FM
    
    % 1. Calcular Lambdas Base (Clientes por segundo reales)
    raw_lambda_AM = am_stats.total_media / T_sesion;
    raw_lambda_FM = fm_stats.total_media / T_sesion;
    
    % 2. Aplicar la corrección (Escenario simulado)
    target_lambda_AM = raw_lambda_AM * factor_correccion_AM;
    target_lambda_FM = raw_lambda_FM * factor_correccion_FM;
    
    % 3. Recalcular el Lambda Total del sistema
    lambda_total_simulacion = target_lambda_AM + target_lambda_FM;
    
    % 4. Recalcular la Probabilidad de Split (Crucial para el bloque Assign)
    prob_AM_corregida = target_lambda_AM / lambda_total_simulacion;
    
    % Tasas de Slow
    prob_slow_AM = am_stats.slow_rate_media; 
    prob_slow_FM = fm_stats.slow_rate_media; 

    fprintf('? Parámetros ajustados (Factor FM: x%.1f):\n', factor_correccion_FM);
    fprintf('   Lambda TOTAL (Generador): %.4f clientes/seg\n', lambda_total_simulacion);
    fprintf('   ------------------------------------------------\n');
    fprintf('   Probabilidad AM (Split): %.2f%%\n', prob_AM_corregida * 100);
    fprintf('   Probabilidad FM (Split): %.2f%% (Antes era menor)\n', (1 - prob_AM_corregida) * 100);
    
catch ME
    error('? Error al calcular parámetros: %s', ME.message);
end

%% Paso 4: Validar y guardar
fprintf('\n4. Guardando parámetros finales...\n');

% Validación de seguridad
if prob_AM_corregida <= 0.01, prob_AM_corregida = 0.01; end
if prob_AM_corregida >= 0.99, prob_AM_corregida = 0.99; end

parametros_reales = struct();
% Guardamos el lambda CORREGIDO
parametros_reales.lambda_total = lambda_total_simulacion; 
parametros_reales.lambda_AM = target_lambda_AM;
parametros_reales.lambda_FM = target_lambda_FM;

% Guardamos la probabilidad CORREGIDA (NOTA: Se guarda como prob_AM)
parametros_reales.prob_AM = prob_AM_corregida; 

parametros_reales.prob_slow_AM = prob_slow_AM;
parametros_reales.prob_slow_FM = prob_slow_FM;
parametros_reales.mu_log = mu_log;       % Agregamos mu para lognormal
parametros_reales.sigma_log = sigma_log; % Agregamos sigma para lognormal
parametros_reales.fecha_generacion = datetime('now');
parametros_reales.version = '3.0_corregida_FM';

save('output\parametros_reales.mat', 'parametros_reales');

%% Paso 5: Generar código para funciones
fprintf('\n5. Generando código para funciones...\n');

% NOTA: Aquí inyectamos los valores calculados arriba.

% Código para InterArrival_General (Usa Lognormal)
codigo_interarrival = ['function t = InterArrival_General(~)' char(10) ...
    '%% Generado por iniciar_presimulacion.m - ' datestr(now) char(10) ...
    'persistent init mu_log sigma_log;' char(10) ...
    'if isempty(init)' char(10) ...
    '    mu_log = ' num2str(mu_log, '%.6f') ';' char(10) ...
    '    sigma_log = ' num2str(sigma_log, '%.6f') ';' char(10) ...
    '    init = 1;' char(10) ...
    'end' char(10) ...
    't = lognrnd(mu_log, sigma_log);' char(10) ...
    'if t <= 0 || t > 3600' char(10) ...
    '    t = 10;' char(10) ...
    'end' char(10) ...
    'end'];

% Código para InterArrival_General (EXPONENCIAL)
codigo_interarrival_exp = ['function t = InterArrival_General_exp(~)' char(10) ...
    '%% Generado por iniciar_presimulacion.m - ' datestr(now) char(10) ...
    'persistent init lambda_total;' char(10) ...
    'if isempty(init)' char(10) ...
    '    lambda_total = ' num2str(lambda_total_simulacion, '%.6f') ';' char(10) ...
    '    init = 1;' char(10) ...
    'end' char(10) ...
    't = exprnd(1/lambda_total);' char(10) ...
    'if t <= 0 || t > 3600' char(10) ...
    '    t = 10;' char(10) ...
    'end' char(10) ...
    'end'];

% Código para Assign_Cliente (VERSIÓN SMART ROUTING)
% Esta versión asigna el puerto basándose en la velocidad del usuario
codigo_assign = ['function [bitrate, emisora, userSpeed, duration, targetPort] = Assign_Cliente(trigger)' char(10) ...
    '%% Generado por iniciar_presimulacion.m - ' datestr(now) ' (MODO INTELIGENTE)' char(10) ...
    'persistent init prob_AM prob_slow_AM prob_slow_FM;' char(10) ...
    'if isempty(init)' char(10) ...
    '    prob_AM = ' num2str(prob_AM_corregida, '%.6f') ';' char(10) ...
    '    prob_slow_AM = ' num2str(prob_slow_AM, '%.6f') ';' char(10) ...
    '    prob_slow_FM = ' num2str(prob_slow_FM, '%.6f') ';' char(10) ...
    '    init = 1;' char(10) ...
    'end' char(10) ...
    char(10) ...
    '%% 1. Asignar Emisora' char(10) ...
    'r = rand();' char(10) ...
    'if r < prob_AM' char(10) ...
    '    emisora = 0; %% AM' char(10) ...
    'else' char(10) ...
    '    emisora = 1; %% FM' char(10) ...
    'end' char(10) ...
    char(10) ...
    '%% 2. Asignar userSpeed (PRIORITARIO)' char(10) ...
    '%% Primero determinamos la capacidad del usuario antes de asignarle servidor' char(10) ...
    'if emisora == 0' char(10) ...
    '    if rand() < prob_slow_AM' char(10) ...
    '        userSpeed = round(normrnd(80, 20));' char(10) ...
    '        if userSpeed <= 0, userSpeed = 50; end' char(10) ...
    '    else' char(10) ...
    '        userSpeed = round(normrnd(160, 30));' char(10) ...
    '    end' char(10) ...
    'else' char(10) ...
    '    if rand() < prob_slow_FM' char(10) ...
    '        userSpeed = round(normrnd(80, 20));' char(10) ...
    '        if userSpeed <= 0, userSpeed = 50; end' char(10) ...
    '    else' char(10) ...
    '        userSpeed = round(normrnd(160, 30));' char(10) ...
    '    end' char(10) ...
    'end' char(10) ...
    char(10) ...
    '%% 3. Ruteo Inteligente (Smart Routing)' char(10) ...
    '%% Asignamos el mejor bitrate que el usuario soporte SIN cortes' char(10) ...
    'if userSpeed >= 128' char(10) ...
    '    bitrate = 128;' char(10) ...
    '    targetPort = 1; %% Calidad Alta' char(10) ...
    'elseif userSpeed >= 96' char(10) ...
    '    bitrate = 96;' char(10) ...
    '    targetPort = 2; %% Calidad Media' char(10) ...
    'else' char(10) ...
    '    bitrate = 64;' char(10) ...
    '    targetPort = 3; %% Calidad Baja (Salvavidas)' char(10) ...
    'end' char(10) ...
    char(10) ...
    '%% 4. Asignar duration' char(10) ...
    'if emisora == 0' char(10) ...
    '    duration = round(normrnd(300, 60));' char(10) ...
    'else' char(10) ...
    '    duration = round(normrnd(240, 40));' char(10) ...
    'end' char(10) ...
    'if duration <= 0' char(10) ...
    '    duration = 60;' char(10) ...
    'end' char(10) ...
    'end'];

% Guardar archivos
fid0 = fopen('output\InterArrival_General_exp_code.m', 'w');
fwrite(fid0, codigo_interarrival_exp, 'char');
fclose(fid0);

fid1 = fopen('output\InterArrival_General_code.m', 'w');
fwrite(fid1, codigo_interarrival, 'char');
fclose(fid1);

fid2 = fopen('output\Assign_Cliente_code.m', 'w');
fwrite(fid2, codigo_assign, 'char');
fclose(fid2);

% Calcular y mostrar tiempo total
tiempo_total = toc;
horas = floor(tiempo_total / 3600);
minutos = floor((tiempo_total - horas * 3600) / 60);
segundos = tiempo_total - horas * 3600 - minutos * 60;


fprintf('\n? ¡PIPELINE COMPLETADO EXITOSAMENTE!\n');
fprintf('Archivos generados:\n');
fprintf('  - output\\parametros_reales.mat\n');
fprintf('  - output\\InterArrival_General_code.m\n');
fprintf('  - output\\Assign_Cliente_code.m (Versión Inteligente)\n');
fprintf('\nTiempo de ejecución: %02d:%02d:%02.1f (hh:mm:ss)\n', horas, minutos, segundos);